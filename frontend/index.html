<!DOCTYPE html>
<html>
<head>
  <title>DeFiCore createPool (web3.js)</title>
  <script src="https://cdn.jsdelivr.net/gh/ethereum/web3.js@1.0.0-beta.36/dist/web3.min.js"></script>
</head>
<body>
  <h2>createPool (Sepolia via MetaMask)</h2>

  <button id="connectButton">Connect Wallet</button><br><br>

  <!-- <label>Token A Address:</label><br>
  <input id="tokenA" size="60" placeholder="0x..." /><br><br>

  <label>Token B Address:</label><br>
  <input id="tokenB" size="60" placeholder="0x..." /><br><br> -->

  <label for="tokenA-select">Select Token A:</label><br>
  <select id="tokenA-select" onchange="updateTokenAddress('tokenA-select', 'tokenA')">
    <option value="">--Choose Token A--</option>
    <option value="0x660B18397606554a58a8F27EE0ABcfB02D2d02b9">TokenA</option>
    <option value="0x81D66cEFdA98b179E4662790b49baE9A0b51cFb9">TokenB</option>
    <option value="0xBA65136E6513c6DD75d5944fE4c993974D7a069f">TokenC</option>
    <option value="0x78BA01CB74d2f2BfeD06bB6a751208220246dA75">TokenD</option>
  </select><br><br>
  
  <label>Token A Address:</label><br>
  <input id="tokenA" size="60" readonly placeholder="0x..." /><br><br>
  
  <label for="tokenB-select">Select Token B:</label><br>
  <select id="tokenB-select" onchange="updateTokenAddress('tokenB-select', 'tokenB')">
    <option value="">--Choose Token B--</option>
    <option value="0x660B18397606554a58a8F27EE0ABcfB02D2d02b9">TokenA</option>
    <option value="0x81D66cEFdA98b179E4662790b49baE9A0b51cFb9">TokenB</option>
    <option value="0xBA65136E6513c6DD75d5944fE4c993974D7a069f">TokenC</option>
    <option value="0x78BA01CB74d2f2BfeD06bB6a751208220246dA75">TokenD</option>
  </select><br><br>
  
  <label>Token B Address:</label><br>
  <input id="tokenB" size="60" readonly placeholder="0x..." /><br><br>

  <label>Amount A (number):</label><br>
  <input id="amountA" placeholder="e.g., 1000000000000000000" /><br><br>

  <label>Amount B (number):</label><br>
  <input id="amountB" placeholder="e.g., 2000000000000000000" /><br><br>

  <button id="createPoolButton">Create Pool</button>

  <pre id="output"></pre>

  <pre id="poolList"></pre>

  <br><br>
    <br><br>

    <h3>Check Pool Liquidity by ID</h3>
    <input type="text" id="liquidityPoolIdInput" placeholder="e.g. pool0" />
    <button id="checkLiquidityButton">Check Liquidity</button>
    <pre id="checkLiqOut"></pre>

    <h3>Check Pool Token Address by ID</h3>
    <input type="text" id="addressPoolIdInput" placeholder="e.g. pool0" />
    <button id="checkPoolTokenButton">Check Token Addresses</button>
    <pre id="poolTokenNumOutAddr"></pre>

  

    <h3>Mint ERC-20 Token to Other User</h3>

    
<label>Other Contract Address:</label><br>
<input id="mintTokenAddress" size="60" placeholder="0x..." /><br><br>

<label>Other User Address:</label><br>
<input id="spenderAddress" size="60" placeholder="0x..." /><br><br>

<label>Amount to Mint:</label><br>
<input id="mintAmount" placeholder="e.g., 1000000" /><br><br>

<button id="mintButton">Approve Token</button>
<pre id="mintOutput"></pre>

<h3>Add Liquidity to Pool</h3>

<label for="addLiqInput">Pool ID:</label>
<input type="text" id="addLiqInput" placeholder="pool0" size="10"><br><br>

<label>Amount A:</label><br>
<input id="liquidityAmountA" placeholder="e.g., 1000000" /><br><br>

<label>Amount B:</label><br>
<input id="liquidityAmountB" placeholder="e.g., 2000000" /><br><br>

<button id="addLiquidityButton">Add Liquidity</button>
<pre id="liquidityOutput"></pre>

<h3>Add One Liquidity to Pool</h3>

<label for="addLiqOneInput">Pool ID:</label>
<input type="text" id="addLiqOneInput" placeholder="pool0" size="10"><br><br>

<label for="token-add-one-select">Select Token to Add:</label><br>
<select id="token-add-one-select" onchange="updateTokenAddress('token-add-one-select', 'token-add-oned')">
  <option value="">--Choose Token to Add--</option>
  <option value="0x660B18397606554a58a8F27EE0ABcfB02D2d02b9">TokenA</option>
  <option value="0x81D66cEFdA98b179E4662790b49baE9A0b51cFb9">TokenB</option>
  <option value="0xBA65136E6513c6DD75d5944fE4c993974D7a069f">TokenC</option>
  <option value="0x78BA01CB74d2f2BfeD06bB6a751208220246dA75">TokenD</option>
</select><br><br>

<label>Token Address to Add:</label><br>
<input id="token-add-oned" size="60" readonly placeholder="0x..." /><br><br>

<label>Amount A:</label><br>
<input id="liquidityAmountOneA" placeholder="e.g., 1000000" /><br><br>

<button id="addLiquidityOneButton">Add Liquidity</button>
<pre id="addLiqOneOutput"></pre>


<h2>Remove Liquidity</h2>

<input type="text" id="liquidityRemovePoolIdInput" placeholder="e.g. pool0" />
<label for="shareInput">Share to remove:</label><br />
<input id="shareInput" min="1" placeholder="Enter share amount" /><br /><br />

<button id="removeLiquidityBtn">Remove Liquidity</button>

<pre id="remLiqOut"></pre>

<h2>Swap Tokens</h2>
<!-- <label for="tokenInInput">Token In Address:</label>
<input type="text" id="tokenInInput" placeholder="0x..." size="42"><br><br> -->

<label for="token-select-swap">Select Token to Swap:</label><br>
<select id="token-select-swap" onchange="updateTokenAddress('token-select-swap', 'token-swap')">
  <option value="">--Choose Token to Swap--</option>
  <option value="0x660B18397606554a58a8F27EE0ABcfB02D2d02b9">TokenA</option>
  <option value="0x81D66cEFdA98b179E4662790b49baE9A0b51cFb9">TokenB</option>
  <option value="0xBA65136E6513c6DD75d5944fE4c993974D7a069f">TokenC</option>
  <option value="0x78BA01CB74d2f2BfeD06bB6a751208220246dA75">TokenD</option>
</select><br><br>

<label>Token Address to Swap:</label><br>
<input id="token-swap" size="60" readonly placeholder="0x..." /><br><br>

<label for="amountInInput">Amount In:</label>
<input type="number" id="amountInInput" min="1"><br><br>

<label for="swapPoolIdInput">Pool ID:</label>
<input type="text" id="swapPoolIdInput" placeholder="pool0" size="10"><br><br>

<button id="swapBtn">Swap</button>

<p id="swapOutput"></p>

<h2>Read My Shares</h2>
<input type="text" id="mySharePoolIdInput" placeholder="e.g. pool0" />
<button id="mySharesPoolBtn">Read My Share</button>
<button id="readTotalSharesBtn">Read Total Shares</button>
<pre id="sharePoolOut"></pre>

<h3>Read Total Interest</h3>
<label>LendingCore Address:</label><br>
<input id="lendingCoreAddress" placeholder="0x..." size="60" /><br><br>
<button id="readInterestBtn">Read Interest Info</button>
<pre id="interestOutput"></pre>

<h3>Lend Token A</h3>
<input id="poolAddrA" placeholder="Pool address" size="60" /><br>
<input id="amountA" placeholder="Amount (in whole units)" /><br>
<button id="lendAButton">Lend Token A</button>
<br><br>

<h3>Lend Token B</h3>
<input id="poolAddrB" placeholder="Pool address" size="60" /><br>
<input id="amountB" placeholder="Amount (in whole units)" /><br>
<button id="lendBButton">Lend Token B</button>

<pre id="lendResult"></pre>

<h2>Borrow Token A</h2>

  <label for="collateralAmount">Collateral Amount:</label>
  <input type="text" id="collateralAmount" placeholder="e.g., 1000000000000000000"><br><br>

  <label for="borrowAmount">Borrow Amount (in wei):</label>
  <input type="text" id="borrowAmount" placeholder="e.g., 500000000000000000"><br><br>

  <label for="borrowAPoolIdInput">Pool ID:</label>
<input type="text" id="borrowAPoolIdInput" placeholder="pool0" size="10"><br><br>

  <button onclick="borrowTokenA()">Borrow</button>

  <p id="status"></p>


  <h2>Borrow Token B</h2>

  <label for="collateralAmountB">Collateral Amount:</label>
  <input type="text" id="collateralAmountB" placeholder="e.g., 1000000000000000000"><br><br>

  <label for="borrowAmountB">Borrow Amount (in wei):</label>
  <input type="text" id="borrowAmountB" placeholder="e.g., 500000000000000000"><br><br>

  <label for="borrowBPoolIdInput">Pool ID:</label>
  <input type="text" id="borrowBPoolIdInput" placeholder="pool0" size="10"><br><br>

  <button onclick="borrowTokenB()">Borrow</button>

  <p id="statusB"></p>

  <h2>Liquidation Panel</h2>

  <label for="userAddressLiqui">User Address:</label>
  <input type="text" id="userAddressLiqui" placeholder="0xUser..." /><br><br>

  <label for="poolAddressLiquiPoolIdInput">Pool ID:</label>
   <input type="text" id="poolAddressLiquiPoolIdInput" placeholder="pool0" size="10"><br><br>

  <button onclick="liquidateUser()">Liquidate</button>

  <pre id="logLiquidation"></pre>
  
  <h2>Loan Repayment Module</h2>

  <label for="repayPoolAddressIdInput">Pool ID:</label>
   <input type="text" id="repayPoolAddressIdInput" placeholder="pool0" size="10"><br><br>

  <label for="repayAmountInput">Repayment Amount (in wei):</label>
  <input type="text" id="repayAmountInput" placeholder="Amount..." /><br><br>

  <button onclick="repayLoanHandler()">Repay Loan</button>

  <pre id="repayStatusMessage"></pre>

  <h2>Withdraw Token A</h2>

  <label for="withdrawPoolAddressIdInput">Pool Address:</label>
  <input type="text" id="withdrawPoolAddressIdInput" placeholder="pool0..." /><br><br>

  <button onclick="withdrawTokenAHandler()">Withdraw</button>

  <pre id="withdrawStatusMessage"></pre>

  <h2>Withdraw Token B</h2>

  <label for="withdrawPoolAddressIdInputB">Pool Address:</label>
  <input type="text" id="withdrawPoolAddressIdInputB" placeholder="pool0..." /><br><br>

  <button onclick="withdrawTokenBHandler()">Withdraw</button>

  <pre id="withdrawStatusMessageB"></pre>

  <h2>Health Factor Checker</h2>

  <label for="healthUserAddressInput">User Address:</label>
  <input type="text" id="healthUserAddressInput" placeholder="0xUser..." /><br><br>

  <label for="healthPoolAddressIdInput">Pool Address:</label>
  <input type="text" id="healthPoolAddressIdInput" placeholder="pool0..." /><br><br>

  <button onclick="getHealthFactorHandler()">Check Health Factor</button>

  <p id="healthFactorStatusMessage"></p>



  <script>

    function updateTokenAddress(selectId, inputId) {
    const select = document.getElementById(selectId);
    const input = document.getElementById(inputId);
    input.value = select.value;
    }

    const pools = []; // Stores created pool addresses

    function updatePoolListUI() {
    const list = document.getElementById("poolList");
    let text = "Pools:\n";
    pools.forEach((address, index) => {
        text += `pool${index} - ${address}\n`;
    });
    list.textContent = text;
    }

    let lastPoolAddress = null;

    const contractAddress = "0xd6efef68957C1E90be60e959AAb8205afD3C95c7"; // DeFiCore on Sepolia

    const lendingCoreAddress = "0x18D78080490Aac9Fc34d7eFcaF857B3DD03dF6D5"; // DeFiCore on Sepolia


    let web3;
    let contract;
    let userAccount;

    document.getElementById("connectButton").onclick = async () => {
      if (window.ethereum) {
        try {
          await window.ethereum.request({ method: "eth_requestAccounts" });
          web3 = new Web3(window.ethereum);
          const accounts = await web3.eth.getAccounts();
          userAccount = accounts[0];
          document.getElementById("output").textContent = `‚úÖ Connected: ${userAccount}`;
        } catch (err) {
          document.getElementById("output").textContent = `‚ùå Connection error: ${err.message}`;
        }
      } else {
        alert("Please install MetaMask!");
      }
    };

    document.getElementById("createPoolButton").onclick = async () => {
        const tokenA = document.getElementById("tokenA-select").value;
        const tokenB = document.getElementById("tokenB-select").value;
        console.log(tokenA);
        console.log(tokenB);
        const amountA = document.getElementById("amountA").value;
        const amountB = document.getElementById("amountB").value;

        let poolAddress;

        let index = 0;

        console.log("AAAAAA");

        if (!tokenA || !tokenB || !amountA || !amountB) {
            document.getElementById("output").textContent = "‚ùå All fields are required.";
            return;
        }

        try {
            document.getElementById("output").textContent = "‚è≥ Sending createPool transaction...";
            const functionSignature = "createPool(address,address,uint256,uint256)";
            const functionSelector = web3.utils.sha3(functionSignature).substring(0, 10); // First 4 bytes

            // Encode the parameters
            const encodedParameters = web3.eth.abi.encodeParameters(
            ["address", "address", "uint256" , "uint256"],
            [tokenA, tokenB, amountA, amountB]
            ).substring(2); // Remove '0x' prefix

            // Construct the full data payload
            const data = functionSelector + encodedParameters;

            // Send the transaction
            const tx = {
            from: userAccount,
            to: contractAddress,
            data: data
            };

            const receipt = await web3.eth.sendTransaction(tx);

            

            
            
            

            document.getElementById("output").textContent =
            `‚úÖ Pool created successfully!\n\nüì¶ Pool address: ${poolAddress}`;

            // 1. Function selector for getPool(address,address)
            const selector = web3.utils.sha3("getPool(address,address)").substring(0, 10); // First 4 bytes

            // 2. Encode the two address parameters (32 bytes each)
            const tokenAEncoded = tokenA.toLowerCase().replace("0x", "").padStart(64, "0");
            const tokenBEncoded = tokenB.toLowerCase().replace("0x", "").padStart(64, "0");

            // 3. Concatenate selector + encoded parameters
            const data2 = selector + tokenAEncoded + tokenBEncoded;

            try {
            // 4. Perform the low-level call
            const result = await web3.eth.call({
                to: contractAddress,
                data: data2
            });

            // 5. Decode the returned address
            poolAddress = web3.utils.toChecksumAddress("0x" + result.slice(26)); // last 20 bytes
            console.log("‚úÖ Pool address:", poolAddress);

            lastPoolAddress = poolAddress;
            pools.push(poolAddress); // Add to list

            updatePoolListUI();      // Update screen

            } catch (err) {
            console.error("‚ùå Error calling getPool:", err.message || err);
            return null;
            }
            } catch (err) {
                console.error(err);
                document.getElementById("output").textContent = "‚ùå Error: " + (err.message || err);
            }
       
            try {
        // Compute the function selector for 'approve(address,uint256)'
        const functionSignature = "approve(address,uint256)";
        const functionSelector = web3.utils.sha3(functionSignature).substring(0, 10); // First 4 bytes

        // Encode the parameters
        const encodedParameters = web3.eth.abi.encodeParameters(
        ["address", "uint256"],
        [poolAddress, 10000]
        ).substring(2); // Remove '0x' prefix

        // Construct the full data payload
        const data = functionSelector + encodedParameters;

        // Send the transaction
        const tx = {
        from: userAccount,
        to: tokenA,
        data: data
        };

        document.getElementById("output").textContent = "‚è≥ Sending approve transaction for token A for 10000...";

        const receipt = await web3.eth.sendTransaction(tx);

        document.getElementById("output").textContent =
        `‚úÖ Approved 10000 tokens to ${poolAddress}\n\nTx Hash: ${receipt.transactionHash}`;
    } catch (err) {
        console.error(err);
        document.getElementById("output").textContent =
        "‚ùå Error approving tokens: " + (err.message || err);
    }
    try {
        // Compute the function selector for 'approve(address,uint256)'
        const functionSignature = "approve(address,uint256)";
        const functionSelector = web3.utils.sha3(functionSignature).substring(0, 10); // First 4 bytes

        // Encode the parameters
        const encodedParameters = web3.eth.abi.encodeParameters(
        ["address", "uint256"],
        [poolAddress, 10000]
        ).substring(2); // Remove '0x' prefix

        // Construct the full data payload
        const data = functionSelector + encodedParameters;

        // Send the transaction
        const tx = {
        from: userAccount,
        to: tokenB,
        data: data
        };

        document.getElementById("output").textContent = "‚è≥ Sending approve transaction for token B for 10000...";

        const receipt = await web3.eth.sendTransaction(tx);

        document.getElementById("output").textContent =
        `‚úÖ Approved 10000 tokens to ${poolAddress}\n\nTx Hash: ${receipt.transactionHash}`;
    } catch (err) {
        console.error(err);
        document.getElementById("output").textContent =
        "‚ùå Error approving tokens: " + (err.message || err);
    }
    };

document.getElementById("checkLiquidityButton").onclick = async () => {
  const poolId = document.getElementById("liquidityPoolIdInput").value.trim().toLowerCase();

  console.log("AAAAAA");

  if (!poolId.startsWith("pool") || isNaN(poolId.slice(4))) {
    document.getElementById("checkLiqOut").textContent = "‚ùå Invalid pool ID format. Use pool0, pool1, etc.";
    return;
  }

  const index = parseInt(poolId.slice(4));
  if (index < 0 || index >= pools.length) {
    document.getElementById("checkLiqOut").textContent = "‚ùå Pool ID out of range.";
    return;
  }

  const selectedAddress = pools[index];

  try {
    document.getElementById("checkLiqOut").textContent = "‚è≥ Reading liquidityA and liquidityB...";

    const liquidityASelector = web3.utils.sha3("liquidityA()").substring(0, 10);
    const liquidityBSelector = web3.utils.sha3("liquidityB()").substring(0, 10);

    const liquidityAResult = await web3.eth.call({ to: selectedAddress, data: liquidityASelector });
    const liquidityBResult = await web3.eth.call({ to: selectedAddress, data: liquidityBSelector });

    const decodedLiquidityA = web3.eth.abi.decodeParameter("uint256", liquidityAResult);
    const decodedLiquidityB = web3.eth.abi.decodeParameter("uint256", liquidityBResult);

    document.getElementById("checkLiqOut").textContent =
      `üìä Liquidity for ${poolId} at ${selectedAddress}:\nüíß liquidityA: ${decodedLiquidityA}\nüíß liquidityB: ${decodedLiquidityB}`;
  } catch (err) {
    console.error(err);
    document.getElementById("checkLiqOut").textContent =
      "‚ùå Error reading liquidityA/liquidityB: " + (err.message || err);
  }
};

document.getElementById("mintButton").onclick = async () => {
  const tokenAddress = document.getElementById("mintTokenAddress").value;
  const spender = document.getElementById("spenderAddress").value;
  const amount = document.getElementById("mintAmount").value;

  if (!web3 || !userAccount) {
    document.getElementById("mintOutput").textContent = "‚ùå Connect wallet first.";
    return;
  }

  if (!tokenAddress || !spender || !amount) {
    document.getElementById("mintOutput").textContent = "‚ùå Fill all approve fields.";
    return;
  }

  try {
    // Compute the function selector for 'approve(address,uint256)'
    const functionSignature = "mint(address,uint256)";
    const functionSelector = web3.utils.sha3(functionSignature).substring(0, 10); // First 4 bytes

    // Encode the parameters
    const encodedParameters = web3.eth.abi.encodeParameters(
      ["address", "uint256"],
      [spender, amount]
    ).substring(2); // Remove '0x' prefix

    // Construct the full data payload
    const data = functionSelector + encodedParameters;

    // Send the transaction
    const tx = {
      from: userAccount,
      to: tokenAddress,
      data: data
    };

    document.getElementById("mintOutput").textContent = "‚è≥ Sending mint transaction...";

    const receipt = await web3.eth.sendTransaction(tx);

    document.getElementById("mintOutput").textContent =
      `‚úÖ Minted ${amount} tokens to ${spender}\n\nTx Hash: ${receipt.transactionHash}`;
  } catch (err) {
    console.error(err);
    document.getElementById("mintOutput").textContent =
      "‚ùå Error minting tokens: " + (err.message || err);
  }

  try {
    // Compute the function selector for 'approve(address,uint256)'
    const functionSignature = "approve(address,uint256)";
    const functionSelector = web3.utils.sha3(functionSignature).substring(0, 10); // First 4 bytes

    // Encode the parameters
    const encodedParameters = web3.eth.abi.encodeParameters(
      ["address", "uint256"],
      [spender, amount]
    ).substring(2); // Remove '0x' prefix

    // Construct the full data payload
    const data = functionSelector + encodedParameters;

    // Send the transaction
    const tx = {
      from: userAccount,
      to: tokenAddress,
      data: data
    };

    document.getElementById("mintOutput").textContent = "‚è≥ Sending approve transaction...";

    const receipt = await web3.eth.sendTransaction(tx);

    document.getElementById("mintOutput").textContent =
      `‚úÖ Approved ${amount} tokens to ${spender}\n\nTx Hash: ${receipt.transactionHash}`;
  } catch (err) {
    console.error(err);
    document.getElementById("mintOutput").textContent =
      "‚ùå Error approving tokens: " + (err.message || err);
  }
};
document.getElementById("addLiquidityButton").onclick = async () => {

    const poolId = document.getElementById("addLiqInput").value.trim().toLowerCase();
    const index = parseInt(poolId.slice(4));
    const poolAddress = pools[index];
  
  const amountA = document.getElementById("liquidityAmountA").value;
  const amountB = document.getElementById("liquidityAmountB").value;

  if (!web3 || !userAccount) {
    document.getElementById("liquidityOutput").textContent = "‚ùå Connect wallet first.";
    return;
  }

  if (!poolAddress || !amountA || !amountB) {
    document.getElementById("liquidityOutput").textContent = "‚ùå Fill all fields.";
    return;
  }

  try {
    // 1. Get function selector for addLiquidity(uint256,uint256)
    const functionSelector = web3.utils.sha3("addLiquidity(uint256,uint256)").substring(0, 10);

    // 2. ABI encode the parameters
    const encodedParams = web3.eth.abi.encodeParameters(
      ["uint256", "uint256"],
      [amountA, amountB]
    ).substring(2); // remove "0x"

    // 3. Create full data payload
    const data = functionSelector + encodedParams;

    // 4. Send transaction to the pool contract
    const tx = {
      from: userAccount,
      to: poolAddress,
      data: data
    };

    document.getElementById("liquidityOutput").textContent = "‚è≥ Sending addLiquidity transaction...";

    const receipt = await web3.eth.sendTransaction(tx);

    document.getElementById("liquidityOutput").textContent =
      `‚úÖ Liquidity added successfully!\n\nTx Hash: ${receipt.transactionHash}`;
  } catch (err) {
    console.error(err);
    document.getElementById("liquidityOutput").textContent =
      "‚ùå Error adding liquidity: " + (err.message || err);
  }
};
document.getElementById("addLiquidityOneButton").onclick = async () => {

const poolId = document.getElementById("addLiqOneInput").value.trim().toLowerCase();
const index = parseInt(poolId.slice(4));
const poolAddress = pools[index];

const tokenA_address = document.getElementById("token-add-one-select").value;

const amountA = document.getElementById("liquidityAmountOneA").value;

if (!web3 || !userAccount) {
document.getElementById("addLiqOneOutput").textContent = "‚ùå Connect wallet first.";
return;
}

if (!poolAddress || !amountA || !amountB) {
document.getElementById("addLiqOneOutput").textContent = "‚ùå Fill all fields.";
return;
}

try {
// 1. Get function selector for addLiquidity(uint256,uint256)
const functionSelector = web3.utils.sha3("addLiquidityWithOneToken(address,uint256)").substring(0, 10);

// 2. ABI encode the parameters
const encodedParams = web3.eth.abi.encodeParameters(
  ["address", "uint256"],
  [tokenA_address, amountA]
).substring(2); // remove "0x"

// 3. Create full data payload
const data = functionSelector + encodedParams;

// 4. Send transaction to the pool contract
const tx = {
  from: userAccount,
  to: poolAddress,
  data: data
};

document.getElementById("addLiqOneOutput").textContent = "‚è≥ Sending addLiquidityWithOneToken transaction...";

const receipt = await web3.eth.sendTransaction(tx);

document.getElementById("addLiqOneOutput").textContent =
  `‚úÖ Liquidity added successfully!\n\nTx Hash: ${receipt.transactionHash}`;
} catch (err) {
console.error(err);
document.getElementById("addLiqOneOutput").textContent =
  "‚ùå Error adding liquidity: " + (err.message || err);
}
};

document.getElementById("readInterestBtn").onclick = async () => {
  const contractAddress = document.getElementById("lendingCoreAddress").value;
  const output = document.getElementById("interestOutput");

  if (!contractAddress || !web3) {
    output.textContent = "‚ùå Enter a contract address and connect wallet.";
    return;
  }

  try {
    // Function selectors (first 4 bytes of keccak256 hash)
    const selectorA = web3.utils.sha3("totalTokenAStaked()").substring(0, 10); // "0x..." format
    const selectorB = web3.utils.sha3("totalTokenBStaked()").substring(0, 10);

    // Call totalInterestTokenA
    const resultA = await web3.eth.call({
      to: contractAddress,
      data: selectorA
    });

    // Call totalInterestTokenB
    const resultB = await web3.eth.call({
      to: contractAddress,
      data: selectorB
    });

    // Decode the returned 32-byte hex
    const interestA = web3.utils.toBN(resultA).toString();
    const interestB = web3.utils.toBN(resultB).toString();

    output.textContent = `‚úÖ Total Staked Token A: ${interestA}\n‚úÖ Total Staked Token B: ${interestB}`;
  } catch (err) {
    console.error(err);
    output.textContent = "‚ùå Error reading interest: " + (err.message || err);
  }
};
async function lendToken(which) {
    const user = (await web3.eth.getAccounts())[0];
    const output = document.getElementById("lendResult");

    let poolAddress, amountInput, functionSelector;

    // Get input values
    if (which === "A") {
      poolAddress = document.getElementById("poolAddrA").value.trim();
      amountInput = document.getElementById("amountA").value.trim();
      functionSelector = web3.utils.sha3("lendTokenA(uint256,address)").substring(0, 10);
    } else if (which === "B") {
      poolAddress = document.getElementById("poolAddrB").value.trim();
      amountInput = document.getElementById("amountB").value.trim();
      functionSelector = web3.utils.sha3("lendTokenB(uint256,address)").substring(0, 10);
    } else {
      output.textContent = "‚ùå Invalid token type.";
      return;
    }

    if (!web3 || !user || !poolAddress || !amountInput) {
      output.textContent = "‚ùå Please fill in all fields.";
      return;
    }

    try {
      const coreAddress = document.getElementById("lendingCoreAddress").value; // get LendingCore address from input
      if (!coreAddress) {
        output.textContent = "‚ùå Please provide LendingCore contract address.";
        return;
      }

      // ABI encode parameters: uint256 amount, address poolAddress
      const encodedParams = web3.eth.abi.encodeParameters(
        ["uint256", "address"],
        [amountInput, poolAddress]
      ).substring(2);

      const data = functionSelector + encodedParams;

      const tx = {
        from: user,
        to: coreAddress,
        data: data,
      };

      output.textContent = "‚è≥ Sending lend transaction...";
      const receipt = await web3.eth.sendTransaction(tx);

      output.textContent = `‚úÖ Lend successful!\nTx Hash: ${receipt.transactionHash}`;
    } catch (err) {
      console.error(err);
      output.textContent = "‚ùå Error lending: " + (err.message || err);
    }
  }

  document.getElementById("lendAButton").onclick = () => lendToken("A");
  document.getElementById("lendBButton").onclick = () => lendToken("B");

  
// document.getElementById("viewPoolButton").onclick = async () => {
//   const poolId = document.getElementById("poolIdInput").value.trim().toLowerCase();

//   if (!poolId.startsWith("pool") || isNaN(poolId.slice(4))) {
//     document.getElementById("poolTokensOutput").textContent = "‚ùå Invalid pool ID format. Use pool0, pool1, etc.";
//     return;
//   }

//   const index = parseInt(poolId.slice(4));
//   if (index < 0 || index >= pools.length) {
//     document.getElementById("poolTokensOutput").textContent = "‚ùå Pool ID out of range.";
//     return;
//   }

//   const selectedAddress = pools[index];
//   try {
//     document.getElementById("poolTokensOutput").textContent = "‚è≥ Reading tokenA and tokenB...";

//     const tokenASelector = web3.utils.sha3("tokenA()").substring(0, 10);
//     const tokenBSelector = web3.utils.sha3("tokenB()").substring(0, 10);

//     const tokenAResult = await web3.eth.call({ to: selectedAddress, data: tokenASelector });
//     const tokenBResult = await web3.eth.call({ to: selectedAddress, data: tokenBSelector });

//     const decodedTokenA = web3.eth.abi.decodeParameter("address", tokenAResult);
//     const decodedTokenB = web3.eth.abi.decodeParameter("address", tokenBResult);

//     document.getElementById("poolTokensOutput").textContent =
//       `‚úÖ Pool ${poolId} at ${selectedAddress}\nüîπ tokenA: ${decodedTokenA}\nüîπ tokenB: ${decodedTokenB}`;
//   } catch (err) {
//     console.error(err);
//     document.getElementById("poolTokensOutput").textContent =
//       "‚ùå Error reading tokenA/tokenB: " + (err.message || err);
//   }
// };

document.getElementById("checkPoolTokenButton").onclick = async () => {
  const poolId = document.getElementById("addressPoolIdInput").value.trim().toLowerCase();

  if (!poolId.startsWith("pool") || isNaN(poolId.slice(4))) {
    document.getElementById("poolTokenNumOutAddr").textContent = "‚ùå Invalid pool ID format. Use pool0, pool1, etc.";
    return;
  }

  const index = parseInt(poolId.slice(4));
  if (index < 0 || index >= pools.length) {
    document.getElementById("poolTokenNumOutAddr").textContent = "‚ùå Pool ID out of range.";
    return;
  }

  const selectedAddress = pools[index];

  try {
    document.getElementById("poolTokenNumOutAddr").textContent = "‚è≥ Reading tokenA and tokenB...";

    const tokenASelector = web3.utils.sha3("tokenA()").substring(0, 10);
    const tokenBSelector = web3.utils.sha3("tokenB()").substring(0, 10);

    const tokenAResult = await web3.eth.call({ to: selectedAddress, data: tokenASelector });
    const tokenBResult = await web3.eth.call({ to: selectedAddress, data: tokenBSelector });

    const decodedTokenA = web3.eth.abi.decodeParameter("address", tokenAResult);
    const decodedTokenB = web3.eth.abi.decodeParameter("address", tokenBResult);

    document.getElementById("poolTokenNumOutAddr").textContent =
      `‚úÖ Pool ${poolId} at ${selectedAddress}\nüîπ tokenA: ${decodedTokenA}\nüîπ tokenB: ${decodedTokenB}`;
  } catch (err) {
    console.error(err);
    document.getElementById("poolTokenNumOutAddr").textContent =
      "‚ùå Error reading tokenA/tokenB: " + (err.message || err);
  }
};

    
const removeBtn = document.getElementById("removeLiquidityBtn");
const output = document.getElementById("remLiqOut");
removeBtn.onclick = async () => {
    
        const share = document.getElementById("shareInput").value;
        const poolId = document.getElementById("liquidityRemovePoolIdInput").value.trim().toLowerCase();
        const index = parseInt(poolId.slice(4));
        const selectedAddress = pools[index];
        if (!share || share <= 0) {
            output.textContent = "‚ùå Please enter a valid share amount greater than 0.";
            return;
        }

        if (!web3 || !contract) {
            output.textContent = "‚ùå Web3 or contract not initialized.";
            return;
        }

        output.textContent = "‚è≥ Sending removeLiquidity transaction...";

    try {
        // Compute the function selector for 'approve(address,uint256)'
        const functionSignature = "removeLiquidity(uint256)";
        const functionSelector = web3.utils.sha3(functionSignature).substring(0, 10); // First 4 bytes

        // Encode the parameters
        const encodedParameters = web3.eth.abi.encodeParameters(
        ["uint256"],
        [share]
        ).substring(2); // Remove '0x' prefix

        // Construct the full data payload
        const data = functionSelector + encodedParameters;

        // Send the transaction
        const tx = {
        from: userAccount,
        to: selectedAddress,
        data: data
        };

        document.getElementById("remLiqOut").textContent = "‚è≥ Sending remove liquidity transaction...";

        const receipt = await web3.eth.sendTransaction(tx);

        document.getElementById("remLiqOut").textContent =
        `‚úÖ Removed ${share} tokens from the pool ${index} by ${userAccount}\n\nTx Hash: ${receipt.transactionHash}`;
    } catch (err) {
        console.error(err);
        document.getElementById("remLiqOut").textContent =
        "‚ùå Error removing tokens: " + (err.message || err);
        }
};

const mySharesPoolBtn = document.getElementById("mySharesPoolBtn");

mySharesPoolBtn.onclick = async () => {
  const output = document.getElementById("sharePoolOut");
  const poolId = document.getElementById("mySharePoolIdInput").value.trim().toLowerCase();
  const index = parseInt(poolId.slice(4)); // assumes poolId like "pool0", "pool1", etc.
  const selectedAddress = pools[index];

  if (!web3) {
    output.textContent = "‚ùå Web3 or contract not initialized.";
    return;
  }
  if (!selectedAddress) {
    output.textContent = "‚ùå Invalid pool selected.";
    return;
  }

  try {
    output.textContent = "‚è≥ Reading your LP share...";

    // Calculate selector for lpShares(address)
    const lpSharesSelector = web3.utils.sha3("lpShares(address)").substring(0, 10); // first 4 bytes (8 hex chars + '0x')

    // Encode the parameter: userAddress (padded 32 bytes)

    // ABI-encode the address parameter (no function signature, only params)
    const encodedAddress = web3.eth.abi.encodeParameter("address", userAccount).substring(2); // remove '0x'

    // Construct calldata = selector + encoded parameter
    const calldata = lpSharesSelector + encodedAddress;

    // Call contract
    const result = await web3.eth.call({
    to: selectedAddress, // pool contract address
    data: calldata
    });

    // Decode result as uint256
    const userShare = web3.eth.abi.decodeParameter("uint256", result);

    output.textContent =
      `My LP share for ${poolId} at ${selectedAddress}:\nMy LP Shares: ${userShare}`;
  } catch (err) {
    console.error(err);
    output.textContent = "‚ùå Error reading my share: " + (err.message || err);
  }
};


const readTotalSharesBtn = document.getElementById("readTotalSharesBtn");


readTotalSharesBtn.onclick = async () => {
    const output = document.getElementById("sharePoolOut");
      const poolId = document.getElementById("mySharePoolIdInput").value.trim().toLowerCase();
      const index = parseInt(poolId.slice(4)); // "pool0" => 0
      const selectedAddress = pools[index];

      if (!web3) {
        output.textContent = "‚ùå Web3 not initialized.";
        return;
      }
      if (!selectedAddress) {
        output.textContent = "‚ùå Invalid pool selected.";
        return;
      }

      try {
        output.textContent = "‚è≥ Reading totalShares...";

        // selector for totalShares() - no parameters
        const totalSharesSelector = web3.utils.sha3("totalShares()").substring(0, 10);

        // Call contract with just selector (no params)
        const result = await web3.eth.call({ to: selectedAddress, data: totalSharesSelector });

        const totalShares = web3.eth.abi.decodeParameter("uint256", result);

        output.textContent = `Total shares in ${poolId} at ${selectedAddress}:\n${totalShares}`;
      } catch (err) {
        console.error(err);
        output.textContent = "‚ùå Error reading totalShares: " + (err.message || err);
      }
    };
    const swapBtn = document.getElementById("swapBtn");
    

    swapBtn.onclick = async () => {
      const output = document.getElementById("swapOutput");
      const tokenIn = document.getElementById("token-select-swap").value;
      const amountIn = document.getElementById("amountInInput").value.trim();
      const poolId = document.getElementById("swapPoolIdInput").value.trim().toLowerCase();
      const index = parseInt(poolId.slice(4));
      const selectedAddress = pools[index];

      if (!tokenIn || !web3.utils.isAddress(tokenIn)) {
        output.textContent = "‚ùå Invalid token address.";
        return;
      }

      if (!amountIn || parseFloat(amountIn) <= 0) {
        output.textContent = "‚ùå Please enter a valid amount greater than 0.";
        return;
      }

      if (!web3 || !userAccount) {
        output.textContent = "‚ùå Web3 or account not initialized.";
        return;
      }

      output.textContent = "‚è≥ Sending swap transaction...";

      try {
        const functionSignature = "swap(address,uint256)";
        const functionSelector = web3.utils.sha3(functionSignature).substring(0, 10);

        const encodedParams = web3.eth.abi.encodeParameters(
          ["address", "uint256"],
          [tokenIn, amountIn]
        ).substring(2);

        const data = functionSelector + encodedParams;

        const tx = {
          from: userAccount,
          to: selectedAddress,
          data: data
        };

        const receipt = await web3.eth.sendTransaction(tx);

        output.textContent = `‚úÖ Swapped ${amountIn} of ${tokenIn}\n\nTx Hash: ${receipt.transactionHash}`;
      } catch (err) {
        console.error(err);
        output.textContent = "‚ùå Error swapping tokens: " + (err.message || err);
      }
    };
    async function borrowTokenA() {
  const collateralAmount = document.getElementById('collateralAmount').value;
  const borrowAmount = document.getElementById('borrowAmount').value;
  const status = document.getElementById('status');

  const poolId = document.getElementById("borrowAPoolIdInput").value.trim().toLowerCase();
  const index = parseInt(poolId.slice(4));
  const selectedAddress = pools[index];

  if (!window.ethereum) {
    alert('MetaMask is required!');
    return;
  }

  await ethereum.request({ method: 'eth_requestAccounts' });
  const accounts = await ethereum.request({ method: 'eth_accounts' });
  const userAccount = accounts[0];

  const functionSignature = "borrowTokenA(uint256,uint256,address)";
  const functionSelector = web3.utils.sha3(functionSignature).substring(0, 10);

  try {
    const encodedParams = web3.eth.abi.encodeParameters(
      ["uint256", "uint256", "address"],
      [collateralAmount, borrowAmount, selectedAddress]
    ).substring(2);

    const data = functionSelector + encodedParams;

    const tx = {
      from: userAccount,
      to: lendingCoreAddress,
      data: data
    };

    const receipt = await web3.eth.sendTransaction(tx);

    status.textContent = `‚úÖ Borrowed ${borrowAmount} Token A using ${collateralAmount} as collateral\n\nTx Hash: ${receipt.transactionHash}`;
  } catch (err) {
    console.error(err);
    status.textContent = "‚ùå Error borrowing Token A: " + (err.message || err);
  }
}

async function borrowTokenB() {
  const collateralAmount = document.getElementById('collateralAmountB').value;
  const borrowAmount = document.getElementById('borrowAmountB').value;
  const status = document.getElementById('statusb');

  const poolId = document.getElementById("borrowBPoolIdInput").value.trim().toLowerCase();
  const index = parseInt(poolId.slice(4));
  const selectedAddress = pools[index];

  if (!window.ethereum) {
    alert('MetaMask is required!');
    return;
  }

  await ethereum.request({ method: 'eth_requestAccounts' });
  const accounts = await ethereum.request({ method: 'eth_accounts' });
  const userAccount = accounts[0];

  const functionSignature = "borrowTokenB(uint256,uint256,address)";
  const functionSelector = web3.utils.sha3(functionSignature).substring(0, 10);

  try {
    const encodedParams = web3.eth.abi.encodeParameters(
      ["uint256", "uint256", "address"],
      [collateralAmount, borrowAmount, selectedAddress]
    ).substring(2);

    const data = functionSelector + encodedParams;

    const tx = {
      from: userAccount,
      to: lendingCoreAddress,
      data: data
    };

    const receipt = await web3.eth.sendTransaction(tx);

    status.textContent = `‚úÖ Borrowed ${borrowAmount} Token B using ${collateralAmount} as collateral\n\nTx Hash: ${receipt.transactionHash}`;
  } catch (err) {
    console.error(err);
    status.textContent = "‚ùå Error borrowing Token B: " + (err.message || err);
  }


}

async function liquidateUser() {
      const user = document.getElementById('userAddressLiqui').value.trim();
      const status = document.getElementById('logLiquidation');

      const poolId = document.getElementById("poolAddressLiquiPoolIdInput").value.trim().toLowerCase();
        const index = parseInt(poolId.slice(4));
        const selectedAddress = pools[index];

      if (!window.ethereum) {
        alert("MetaMask is required!");
        return;
      }

      try {
        const functionSignature = "liquidate(address,address)";
        const functionSelector = web3.utils.sha3(functionSignature).substring(0, 10);

        const encodedParams = web3.eth.abi.encodeParameters(
          ['address', 'address'],
          [user, selectedAddress]
        ).substring(2);

        const tx = {
          from: userAccount,
          to: lendingCoreAddress,
          data: functionSelector + encodedParams
        };

        const receipt = await web3.eth.sendTransaction(tx);

        status.textContent = `‚úÖ Liquidation successful!\nTx Hash: ${receipt.transactionHash}`;
      } catch (err) {
        console.error(err);
        status.textContent = "‚ùå Error liquidating: " + (err.message || err);
      }
    }

    async function repayLoanHandler() {
      const amount = document.getElementById('repayAmountInput').value.trim();
      const statusEl = document.getElementById('repayStatusMessage');

      const poolId = document.getElementById("repayPoolAddressIdInput").value.trim().toLowerCase();
        const index = parseInt(poolId.slice(4));
        const selectedAddress = pools[index];

      if (!window.ethereum) {
        alert("MetaMask is required!");
        return;
      }

      try {

        const functionSignature = "repayLoan(address,uint256)";
        const functionSelector = web3.utils.sha3(functionSignature).substring(0, 10);

        const encodedParams = web3.eth.abi.encodeParameters(
          ['address', 'uint256'],
          [selectedAddress, amount]
        ).substring(2);

        const tx = {
          from: userAccount,
          to: lendingCoreAddress,
          data: functionSelector + encodedParams
        };

        const receipt = await web3.eth.sendTransaction(tx);

        statusEl.textContent = `‚úÖ Loan repaid: ${amount} wei to ${poolAddress}\nTx Hash: ${receipt.transactionHash}`;
      } catch (err) {
        console.error(err);
        statusEl.textContent = "‚ùå Repayment failed: " + (err.message || err);
      }
    }
   
    async function withdrawTokenAHandler() {
        const poolId = document.getElementById("withdrawPoolAddressIdInput").value.trim().toLowerCase();
        const index = parseInt(poolId.slice(4));
        const selectedAddress = pools[index];

      const statusMsg = document.getElementById('withdrawStatusMessage');

      if (!window.ethereum) {
        alert("MetaMask is required!");
        return;
      }

      try {

        const functionSignature = "withdrawTokenA(address)";
        const functionSelector = web3.utils.sha3(functionSignature).substring(0, 10);

        const encodedParams = web3.eth.abi.encodeParameters(
          ['address'],
          [selectedAddress]
        ).substring(2);

        const tx = {
          from: sender,
          to: lendingCoreAddress,
          data: functionSelector + encodedParams
        };

        const receipt = await web3.eth.sendTransaction(tx);

        statusMsg.textContent = `‚úÖ Withdrawal successful from pool ${poolAddress}\nTx Hash: ${receipt.transactionHash}`;
      } catch (err) {
        console.error(err);
        statusMsg.textContent = "‚ùå Withdrawal failed: " + (err.message || err);
      }
    }


    async function withdrawTokenBHandler() {
        const poolId = document.getElementById("withdrawPoolAddressIdInputB").value.trim().toLowerCase();
        const index = parseInt(poolId.slice(4));
        const selectedAddress = pools[index];

      const statusMsg = document.getElementById('withdrawStatusMessageB');

      if (!window.ethereum) {
        alert("MetaMask is required!");
        return;
      }

      try {

        const functionSignature = "withdrawTokenB(address)";
        const functionSelector = web3.utils.sha3(functionSignature).substring(0, 10);

        const encodedParams = web3.eth.abi.encodeParameters(
          ['address'],
          [selectedAddress]
        ).substring(2);

        const tx = {
          from: sender,
          to: lendingCoreAddress,
          data: functionSelector + encodedParams
        };

        const receipt = await web3.eth.sendTransaction(tx);

        statusMsg.textContent = `‚úÖ Withdrawal successful from pool ${poolAddress}\nTx Hash: ${receipt.transactionHash}`;
      } catch (err) {
        console.error(err);
        statusMsg.textContent = "‚ùå Withdrawal failed: " + (err.message || err);
      }
    }

    async function getHealthFactorHandler() {
      const userAddr = document.getElementById('healthUserAddressInput').value.trim();

      const poolId = document.getElementById("healthPoolAddressIdInput").value.trim().toLowerCase();
        const index = parseInt(poolId.slice(4));
        const selectedAddress = pools[index];

      const statusEl = document.getElementById('healthFactorStatusMessage');

      if (!window.ethereum) {
        alert("MetaMask is required!");
        return;
      }

      try {
        const web3 = new Web3(window.ethereum);

        const healthFactorFunctionSig = "getHealthFactor(address,address)";

        const functionSelector = web3.utils.sha3(healthFactorFunctionSig).substring(0, 10);

        const encodedParams = web3.eth.abi.encodeParameters(
          ['address', 'address'],
          [userAddr, selectedAddress]
        ).substring(2);

        const callData = functionSelector + encodedParams;

        const result = await web3.eth.call({
          to: lendingCoreAddress,
          data: callData
        });

        const healthFactor = web3.utils.toBN(result).toString();

        statusEl.textContent = `‚úÖ Health Factor: ${healthFactor}`;
      } catch (err) {
        console.error(err);
        statusEl.textContent = "‚ùå Failed to fetch health factor: " + (err.message || err);
      }
    }










  </script>
</body>
</html>
